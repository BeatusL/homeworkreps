org 100h
    mov ax, 0        ; Инициализация регистра AX для результата
    mov cx, 0        ; Счётчик сдвигов (shift)
    mov bx, 9h      ; Копируем множитель b в BX
    mov dx, 0bh       ; Загружаем множимое a в DX

loop_start:
    test bx, 1       ; Проверяем младший бит BX (множителя)
    jz skip_addition ; Если бит равен 0, пропускаем сложение

    shl dx, cl       ; Сдвигаем множимое на количество позиций, указанных в CL
    add ax, dx       ; Добавляем частичную сумму к результату (AX)
    shr dx, cl       ; Возвращаем множимое в исходное положение

skip_addition:
    shr bx, 1        ; Сдвигаем BX вправо на 1 бит (переход к следующему биту)
    inc cx           ; Увеличиваем счётчик сдвигов
    test bx, bx      ; Проверяем, не стало ли BX равным 0
    jnz loop_start   ; Если BX не равен 0, продолжаем цикл

    mov [200h], ax   ; Сохраняем результат в памяти
