org 100h

;-------------------------------------------------
;Область входных данных
mov al, 9h       ; AL = A (множимое)
mov bl, 2h		 ; BL = B (множитель)
;-------------------------------------------------


mov [202h], ax   ;сохраняем входные данные для
mov [204h],	bx   ;последующего вывода
call multiply    
;на данный момент множители распалагаются по адресам 202 и 204
;произведение - в 200
;-------------------------------------------------

;Данна область программы разделяет входные и выходные данные
;на десятичные разряды единиц и десятков
;В AX записывается адрес числа, которое следует разделить
;В SI - адрес, куда следует записать результат, 
;десятки пишутся по адресу SI, единицы - SI+1
mov ax, [202h]
mov si, 210h
call divider

mov ax, [204h]
mov si, 212h
call divider

mov ax, [200h]
mov si, 214h
call divider
;-------------------------------------------------

;Очистка адресов с 217 по 22f, тк они используются для вывода
mov si, 217h
mov di, 0h
call clear_loop
;-------------------------------------------------

;Данная область программы отвечает за перевод полученных ранее 
;цифр в 7-сегментный код для вывода на индикаторы
mov al, [210h]
call convert
mov [220h], al

mov al, [211h]
call convert
mov [221h], al

mov al, [212h]
call convert
mov [223h], al

mov al, [213h]
call convert
mov [224h], al

mov al, [214h]
call convert
mov [226h], al

mov al, [215h]
call convert
mov [227h], al
;-------------------------------------------------

;Данный алгоритм вывода базируется на принципе скользящего окна
;По адресам с 217 по 227 расположены выходные данные, в начальный
;момент окно захватывает участок с 217 по 21e ячейки и выводит их
;на следуещем шаге окно сдвигается на 1, исключая первую ячейку из
;вывода и включая ячейку, следующую за последней.
mov bx, 217h

display_frame:
	mov dx, 09eh 
	mov si, bx
	loop_display:
		mov al, [si]
		out dx, al
		cmp dx, 090h
		je outer_loop
		sub dx, 2h
		inc si
		jmp loop_display
	
	outer_loop:
		call wait_frame
		inc bx
		cmp bx, 221h
		je end
		jmp display_frame

end: jmp end
;-------------------------------------------------

multiply:
	mov ax, 0        ; Инициализация регистра AX для результата
    mov cx, 0        ; Счётчик сдвигов (shift)
    mov bx, [204h]       ; Копируем множитель b в BX
    mov dx, [202h]       ; Загружаем множимое a в DX

	loop_start:
		test bx, 1       ; Проверяем младший бит BX (множителя)
		jz skip_addition ; Если бит равен 0, пропускаем сложение

		shl dx, cl       ; Сдвигаем множимое на количество позиций, указанных в CL
		add ax, dx       ; Добавляем частичную сумму к результату (AX)
		shr dx, cl       ; Возвращаем множимое в исходное положение

	skip_addition:
		shr bx, 1        ; Сдвигаем BX вправо на 1 бит (переход к следующему биту)
		inc cx           ; Увеличиваем счётчик сдвигов
		test bx, bx      ; Проверяем, не стало ли BX равным 0
		jnz loop_start   ; Если BX не равен 0, продолжаем цикл

		mov [200h], ax   ; Сохраняем результат в памяти


convert:                ;перевод числа из двоичного в 7-сегментный код
	mov bx, digits      ;адрес таблицы переводов
	add bl, al          ;адрес числа равен числу + начало таблицы
	mov al, [bx]
	ret

clear_loop:            ;адреса с 217 по 22f используются как стек
	mov [si], di       ;данных для вывода, их следует очищать
	inc si             ;перед использованием
	cmp si, 22fh
	jl clear_loop
	ret
	

	
divider:               ;AX - входное число, SI - адрес результата
	xor bx, bx
	mov bl, 10         ; Делитель = 10
	div bl             ; AX / BL -> AL = результат (десятки), AH = остаток (единицы)

	mov [si], al         ; Сохраняем десятки по адресу si
	add si, 1h
	mov [si], ah         ; Сохраняем единицы по адресу si + 1
	ret

wait_frame:            ;задержка перед обновлением вывода
	mov cx, 4650h
	countdown:
		dec cx
		jnz countdown
	ret

digits db 3fh, 06h, 5bh, 4fh, 66h, 6dh, 7dh, 07h, 7fh, 6fh